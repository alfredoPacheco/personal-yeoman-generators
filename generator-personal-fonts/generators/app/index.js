'use strict';


//---------//
// Imports //
//---------//

var generators = require('yeoman-generator')
    , bPromise = require('bluebird')
    , bInquirer = require('bluebird-inquirer')
    , l = require('lambda-js')
    , path = require('path')
    , bFs = require('fs-bluebird')
    , nh = require('node-helpers')
    , ttf2woff = require('ttf2woff')
    , pgc = require('personal-generator-common')
    , bNcp = bPromise.promisifyAll(require('ncp'))
    , bMkdirp = bPromise.promisify(require('mkdirp'));


//------//
// Init //
//------//

var lazy = nh.lazyExtensions;

var PATH_TO_FONT_METADATA = path.join(process.env.HOME, 'data/fonts/METADATA.json');
var DEFAULT_ASSETS_PATH = "/src/client/assets";
var FONTS_SCSS_PATH = "/scss/partials/_fonts.scss";

var fontCss = "/* Generated by project-scaffolder */\n\n";

var fonts
    , assetsPath
    , fontsScssPath
    , moreThan4Fonts
    , fontMetadata;


//------//
// Main //
//------//

module.exports = generators.Base.extend({
    'constructor': function constructor() {
        generators.Base.apply(this, arguments);

        if (arguments[0].length > 2) {
            throw new Error("generator-personal-fonts only expects up to two parameters (project name, fonts scss path).  The following were given: " + arguments[0]);
        }
        this.argument('projectName', {
            required: false
        });

        this.option('emptyProjectName', {
            desc: "Set if you want to use the current directory as the project - This option gets around yeoman's unable to pass empty arguments"
                + " via the command line"
        });
        if (this.options.emptyProjectName === true && this.projectName) {
            throw new Error("Invalid State: option emptyProjectName cannot be set while also passing in a projectName argument");
        } else if (this.options.emptyProjectName) {
            this.projectNameArg = "";
        }

        this.argument('assetsPath', {
            required: false
        });

        if (arguments[0].length > 2) {
            throw new Error("generator-personal-fonts only expects up to two arguments (project name, assets path).  The following were given: " + arguments[0]);
        }
    },
    'initializing': function loadFontMetadata() {
        var done = this.async();

        var metadataFile = path.join(PATH_TO_FONT_METADATA);
        return bFs.readFileAsync(metadataFile)
            .then(function(data) {
                fontMetadata = lazy(JSON.parse(data));
            })
            .then(function() {
                done();
            });
    },
    'prompting': function prompting() {
        var self = this;
        var done = self.async();

        // needed to use project name in multiple generators. The below just initializes the project name, if passed,
        //   by setting our destinationRoot to it plus runs it through a validator.
        var pname = new pgc.ProjectNameState(self);

        bInquirer.prompt([
                pname.getPrompt() // only prompts if a project name wasn't passed in via arguments
                , {
                    'name': 'fonts'
                    , 'message': 'Type a comma-delimited list of fonts to use (or leave empty for none).'
                    , 'type': 'input'
                    , 'validate': function(i) {
                            // empty is fine
                            if (!i) {
                                return true;
                            }

                            // else we need to validate the font typed in against our google font library
                            var tmpFonts = lazy(i.split(','));
                            return tmpFonts.all(function(f) {
                                var md = fontMetadata.get(f);
                                // valid if meta data exists
                                //   and also extension is true type font
                                return !!md && path.extname(md.filename) === '.ttf';
                            });
                        }
                    , 'filter': l('a', 'a.split(",")')
                }
            ])
            .then(function(answers) {
                fonts = answers.fonts;

                if (answers.projectName) {
                    self.destinationRoot(path.join(self.destinationRoot(), answers.projectName));
                } // otherwise destinationRoot was properly set from an argument

                // initializes assets root where fonts directory will live
                assetsPath = self.assetsPath || self.destinationPath(DEFAULT_ASSETS_PATH);

                // initializes _fonts.scss path
                fontsScssPath = path.join(assetsPath, FONTS_SCSS_PATH);
                var fontsScssDir = path.dirname(fontsScssPath);

                return bMkdirp(fontsScssDir);
            })
            .then(function() {
                done();
            });
    },
    'writing': function writing() {
        if (fonts[0] !== '') {
            var self = this;
            var done = self.async();

            moreThan4Fonts = false;
            if (fonts.length > 4) {
                moreThan4Fonts = true;
            }
            var fontCssPromises = fonts
                .map(function(f) {
                    var md = fontMetadata.get(f);
                    return bPromise.join(
                        bFs.readFileAsync(md.filename), md, fontDataToCss
                    );
                });

            bPromise.all(fontCssPromises)
                .then(function() {
                    self.fs.write(fontsScssPath, fontCss);
                })
                .then(done);
        }
    }
});


//---------//
// Helpers //
//---------//

function fontDataToCss(data, md) {
    var woffCss = "";
    var woffBuff = new Buffer(ttf2woff(data).buffer);
    var baseFontName = path.basename(md.filename);
    var pWrite
        , res;

    // if we don't have more than (an arbitrary) 4 fonts files, let's just embed them via base64 into the css
    if (!moreThan4Fonts) {
        var b64 = woffBuff.toString('base64');
        woffCss = "  src: url(data:application/x-font-woff;charset=utf-8;base64," + b64 + ") format('woff')\n";
    } else {
        // more than 4 would likely cause for the file size to be too high, so we'll just reference the local files
        var baseFontNameWoff = baseFontName.replace(/\.[^/.]+$/, "") + ".woff";
        var fullWoff = path.join(assetsPath, 'fonts', baseFontNameWoff);
        pWrite = bFs.writeFileAsync(fullWoff, woffBuff);
        woffCss = "  src: url(fonts/" + baseFontNameWoff + "') format('woff')\n";
    }

    var fullTtf = path.join(assetsPath, 'fonts', baseFontName);

    fontCss = fontCss + "@font-face {\n"
        + "  font-family: '" + md.familyname
        + "';\n" + woffCss + "    , url('../fonts/" + baseFontName + "') format('truetype');\n"
        + "  font-weight: " + md.weight + ";\n"
        + "  font-style: " + md.style + ";\n" + "}\n\n";

    function mkdirAndCopyFont() {
        return bMkdirp(path.dirname(fullTtf))
            .then(function() {
                return bNcp.ncpAsync(md.filename, fullTtf);
            });
    }

    if (pWrite) {
        res = pWrite.then(mkdirAndCopyFont);
    } else {
        res = mkdirAndCopyFont();
    }

    return res;
}
